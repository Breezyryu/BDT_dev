# 벡터화된 병합 로직 (Vectorized GroupBy) 설명

> **대상 코드**: `BatteryDataTool.py` Line 531  
> **작성일**: 2026-02-06

---

## 🔍 코드 분석

```python
merge_group = ((cond_series != cond_series.shift()) | (~cond_series.isin([1, 2]))).cumsum()
```

이 코드는 연속된 충전(1) 또는 방전(2) 데이터를 하나의 그룹으로 묶고, 그 외의 상태나 상태가 변하는 지점을 기준으로 그룹 ID를 부여하는 핵심 로직입니다.

---

### 📊 단계별 동작 원리

#### 1. `cond_series.shift()` - 한 칸 이동
데이터를 한 칸씩 아래로 내립니다. 이를 통해 **이전 행의 값**과 비교할 수 있습니다.
```
원본:       [1, 1, 1, 2, 2, 3, 1, 1]
shift():    [NaN, 1, 1, 1, 2, 2, 3, 1]
```

#### 2. `cond_series != cond_series.shift()` - 값이 바뀌는 지점 감지
현재 값과 이전 값이 다르면 `True`가 됩니다. 즉, **상태(Condition)가 변하는 순간**을 포착합니다.
```
원본:       [1, 1, 1, 2, 2, 3, 1, 1]
shift():    [NaN, 1, 1, 1, 2, 2, 3, 1]
결과:       [True, False, False, True, False, True, True, False]
            ↑ 시작     ↑ 유지   ↑ 변함  ↑ 유지  ↑ 변함
```

#### 3. `~cond_series.isin([1, 2])` - 병합 제외 대상 필터링
충전(1)이나 방전(2)이 **아닌** 행(예: 휴지, 대기)은 병합되지 않고 독립된 그룹이어야 합니다.
따라서 1, 2가 아닌 값은 무조건 `True`로 만들어, 강제로 새로운 그룹이 시작되게 합니다.
```
원본:       [1, 1, 1, 2, 2, 3, 1, 1]
isin([1,2]):[T, T, T, T, T, F, T, T] (1,2인가?)
~(NOT):     [F, F, F, F, F, T, F, F] (1,2가 아닌가?)
                         ↑ 3은 병합 제외
```

#### 4. `| (OR)` - 두 조건 결합
"값이 바뀌었거나" **또는** "충/방전이 아니면" 새로운 그룹으로 간주합니다.
```
조건1 (변화): [T, F, F, T, F, T, T, F]
조건2 (예외): [F, F, F, F, F, T, F, F]
결과 (OR):    [T, F, F, T, F, T, T, F]
```

#### 5. `.cumsum()` - 누적 합으로 그룹 ID 부여
`True` (1)가 나올 때마다 값을 누적하여 증가시킵니다. `False` (0)인 구간은 값이 유지되므로 같은 그룹 ID를 공유하게 됩니다.
```
불리언:     [1, 0, 0, 1, 0, 1, 1, 0] (True=1, False=0)
cumsum:     [1, 1, 1, 2, 2, 3, 4, 4]
            └그룹1┘ └그룹2┘ └3┘└그룹4┘
```

---

### 🎯 최종 결과 예시

```
원본 데이터:  [충전, 충전, 충전, 방전, 방전, 휴지, 충전, 충전]
그룹 ID:      [  1,   1,   1,   2,   2,   3,   4,   4  ]
              └───그룹1───┘ └─그룹2─┘  ↑   └─그룹4─┘
                                      휴지는 단독
```

이 로직을 통해 `groupby(merge_group)`을 수행하면, 연속된 충전/방전 구간을 **단 한 번의 연산**으로 묶어서 처리할 수 있습니다.
